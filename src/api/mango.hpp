// Copyright 2019, University of Maryland and the MANGO development team.
//
// This file is part of MANGO.
//
// MANGO is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// MANGO is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with MANGO.  If not, see
// <https://www.gnu.org/licenses/>.


#ifndef MANGO_H
#define MANGO_H

#include <mpi.h>
#include <string>

//! This C++ namespace contains everything related to MANGO.
namespace mango {

  //! The list of packages, i.e. libraries that MANGO can call to perform optimization.
  /**
   * Note that all packages are enumerated here even if MANGO is built
   * without support for all of them. This list of packages is
   * generated by the update_algorithms script from the master table
   * of algorithms in algorithms.dat.
   */
  typedef enum {
    // <packages>
    // This section was automatically generated by ./update_algorithms
    PACKAGE_HOPSPACK,
    PACKAGE_NLOPT,
    PACKAGE_GSL,
    PACKAGE_PETSC,
    // </packages>
    NUM_PACKAGES //!< Not an actual package, just counting.
  } package_type;

  //! A large finite number
  /** 
   * This number is not yet used in the code.
   */
  const double NUMBER_FOR_FAILED = 1.0e+12;

  //////////////////////////////////////////////////////////////////////////////////////
  // Items related to algorithms:

  //! Some properties of each algorithm that MANGO is aware of.
  typedef struct {
    std::string name; //!< A short string with the algorithm's name, e.g. 'petsc_pounders' or 'hopspack'.
    package_type package; //!< The optimization library that the algorithm belongs to.
    bool least_squares; //!< Whether or not the algorithm assumes the objective function has least-squares form.
    bool uses_derivatives; //!< Whether the algorithm requires derivatives of the objective function or residuals to be supplied.
    bool parallel; //!< Whether the algorithm can support concurrent evaluations of the objective function. Any algorithm that uses derivatives is parallel in this sense, because finite difference derivatives can be computed using concurrent function evaluations.
    bool allows_bound_constraints; //!< Whether the algorithm allows maximum and minimum values (a.k.a. box constraints) to be imposed on the independent variables.
    bool requires_bound_constraints; //!< Whether the algorithm requires maximum and minimum values (a.k.a. box constraints) to be imposed on the independent variables.
  } algorithm_properties;

  //! A list of the algorithms that MANGO can potentially use.
  /** 
   * Each algorithm in this list is only available if MANGO is built
   * with the corresponding package.  This list of packages is
   * generated by the update_algorithms script from the master table
   * of algorithms in algorithms.dat.
   */
  typedef enum {
    // <enum>
    // This section was automatically generated by ./update_algorithms
    PETSC_NM,
    PETSC_POUNDERS,
    PETSC_BRGN,
    NLOPT_GN_DIRECT,
    NLOPT_GN_DIRECT_L,
    NLOPT_GN_DIRECT_L_RAND,
    NLOPT_GN_DIRECT_NOSCAL,
    NLOPT_GN_DIRECT_L_NOSCAL,
    NLOPT_GN_DIRECT_L_RAND_NOSCAL,
    NLOPT_GN_ORIG_DIRECT,
    NLOPT_GN_ORIG_DIRECT_L,
    NLOPT_GN_CRS2_LM,
    NLOPT_LN_COBYLA,
    NLOPT_LN_BOBYQA,
    NLOPT_LN_PRAXIS,
    NLOPT_LN_NELDERMEAD,
    NLOPT_LN_SBPLX,
    NLOPT_LD_MMA,
    NLOPT_LD_CCSAQ,
    NLOPT_LD_SLSQP,
    NLOPT_LD_LBFGS,
    NLOPT_LD_TNEWTON_PRECOND_RESTART,
    NLOPT_LD_TNEWTON_PRECOND,
    NLOPT_LD_TNEWTON_RESTART,
    NLOPT_LD_TNEWTON,
    NLOPT_LD_VAR1,
    NLOPT_LD_VAR2,
    HOPSPACK,
    GSL_LM,
    GSL_DOGLEG,
    GSL_DDOGLEG,
    GSL_SUBSPACE2D,
    GSL_CONJUGATE_FR,
    GSL_CONJUGATE_PR,
    GSL_BFGS,
    GSL_NM,
    // </enum>
    NUM_ALGORITHMS  //!< Not an actual algorithm, just counting.
  } algorithm_type;
  
  //! A database of the algorithms that MANGO is aware of, including various properties of each algorithm.
  /**
   * This databse is automatically generated from the master database algorithms.dat by the update_algorithms script.
   */
  const algorithm_properties algorithms[NUM_ALGORITHMS] = {
    // <database>
    // This section was automatically generated by ./update_algorithms
    // name,                            package,         least_squares, uses_derivatives, parallel, allows_bound_constraints, requires_bound_constraints
    {"petsc_nm",                        PACKAGE_PETSC,   false,         false,            false,    false,                    false},
    {"petsc_pounders",                  PACKAGE_PETSC,   true,          false,            false,    true,                     false},
    {"petsc_brgn",                      PACKAGE_PETSC,   true,          true,             true,     true,                     false},
    {"nlopt_gn_direct",                 PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_direct_l",               PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_direct_l_rand",          PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_direct_noscal",          PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_direct_l_noscal",        PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_direct_l_rand_noscal",   PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_orig_direct",            PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_orig_direct_l",          PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_gn_crs2_lm",                PACKAGE_NLOPT,   false,         false,            false,    true,                     true },
    {"nlopt_ln_cobyla",                 PACKAGE_NLOPT,   false,         false,            false,    true,                     false},
    {"nlopt_ln_bobyqa",                 PACKAGE_NLOPT,   false,         false,            false,    true,                     false},
    {"nlopt_ln_praxis",                 PACKAGE_NLOPT,   false,         false,            false,    true,                     false},
    {"nlopt_ln_neldermead",             PACKAGE_NLOPT,   false,         false,            false,    true,                     false},
    {"nlopt_ln_sbplx",                  PACKAGE_NLOPT,   false,         false,            false,    true,                     false},
    {"nlopt_ld_mma",                    PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_ccsaq",                  PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_slsqp",                  PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_lbfgs",                  PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_tnewton_precond_restart",PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_tnewton_precond",        PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_tnewton_restart",        PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_tnewton",                PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_var1",                   PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"nlopt_ld_var2",                   PACKAGE_NLOPT,   false,         true,             true,     true,                     false},
    {"hopspack",                        PACKAGE_HOPSPACK,false,         false,            true,     true,                     false},
    {"gsl_lm",                          PACKAGE_GSL,     true,          true,             true,     false,                    false},
    {"gsl_dogleg",                      PACKAGE_GSL,     true,          true,             true,     false,                    false},
    {"gsl_ddogleg",                     PACKAGE_GSL,     true,          true,             true,     false,                    false},
    {"gsl_subspace2d",                  PACKAGE_GSL,     true,          true,             true,     false,                    false},
    {"gsl_conjugate_fr",                PACKAGE_GSL,     false,         true,             true,     false,                    false},
    {"gsl_conjugate_pr",                PACKAGE_GSL,     false,         true,             true,     false,                    false},
    {"gsl_bfgs",                        PACKAGE_GSL,     false,         true,             true,     false,                    false},
    {"gsl_nm",                          PACKAGE_GSL,     false,         false,            false,    false,                    false}
    // </database>
  };

  //! Checks whether or not a string corresponds to the name of one of the optimization algorithms known by MANGO.
  /**
     @param algorithm_name A candidate name for an optimization algorithm. These names correspond to the `name` field of the \ref algorithm_properties type.
     @return true if an algorithm exists in MANGO's database with the corresponding name, false otherwise.
  */
  bool does_algorithm_exist(std::string algorithm_name);

  bool get_algorithm(std::string, algorithm_type*);

  //////////////////////////////////////////////////////////////////////////////////////
  // Items related to partitioning the processors into worker groups:

  /** \brief A class for dividing the set of MPI processes into worker groups.
   *
   * Each group works together on evaluations of the objective function.
   */

  class MPI_Partition {
  private:
    MPI_Comm comm_world;
    MPI_Comm comm_worker_groups;
    MPI_Comm comm_group_leaders;
    int N_procs_world;
    int rank_world;
    int N_procs_worker_groups;
    int rank_worker_groups;
    int N_procs_group_leaders;
    int rank_group_leaders;
    int worker_group;
    bool proc0_world;
    bool proc0_worker_groups;
    int N_worker_groups;
    bool initialized;

    void verify_initialized();
    void print();
    void write_line(std::ofstream&, int, std::string[], int[]);

  public:

    //! If true, information is printed to stdout that may be useful for debugging.
    int verbose;

    MPI_Partition();
    ~MPI_Partition();

    void init(MPI_Comm);
    void set_custom(MPI_Comm, MPI_Comm, MPI_Comm);
    MPI_Comm get_comm_world();
    MPI_Comm get_comm_worker_groups();
    MPI_Comm get_comm_group_leaders();
    bool get_proc0_world();
    bool get_proc0_worker_groups();
    int get_rank_world();
    int get_rank_worker_groups();
    int get_rank_group_leaders();
    int get_N_procs_world();
    int get_N_procs_worker_groups();
    int get_N_procs_group_leaders();

    //! Returns an integer indicating the worker group to which this MPI process belongs.
    int get_worker_group();

    //! Returns the number of worker groups.
    int get_N_worker_groups();
    
    //! Set the number of worker groups to the given integer. 
    /**
     * Except when using a custom partition, this method must be
     * called before any of the 'get' methods or before using the
     * MPI_Partition for an optimization. This method does not need to
     * be called when using a custom partition.
     */
    void set_N_worker_groups(int);

    //! Write a file with the given filename, showing the worker group assignments and rank of each process in each communicator.
    void write(std::string filename);

    void stop_workers();
    void mobilize_workers();
    bool continue_worker_loop();
  };

  //////////////////////////////////////////////////////////////////////////////////////
  // Items specific to an optimization problem

  class Problem;
  typedef void (*objective_function_type)(int*, const double*, double*, int*, mango::Problem*, void*);
  typedef void (*residual_function_type)(int*, const double*, int*, double*, int*, mango::Problem*, void*);

  class Solver;
  class Problem {
  protected:
    // Many implementation details are hidden in the Solver class, so users see only the interface provided by Problem.
    Solver* solver;

  public:
    MPI_Partition mpi_partition;

    //! Constructor for a standard optimization problem
    /**
     * @param[in] N_parameters Number of independent variables.
     * @param[in] state_vector An array of size N_parameters, giving the initial values of the independent variables.
     * @param[in] objective_function The objective function to minimize.
     * @param[in] argc (Optional) A number of arguments. Used to pass options to some optimization libraries. 
     * @param[in] argv (Optional) An array of arguments. Used to pass options to some optimization libraries. 
     */
    Problem(int N_parameters, double* state_vector, objective_function_type objective_function, int argc, char** argv); // For non-least-squares problems

    //! Destructor
    ~Problem();

    void mpi_init(MPI_Comm);
    void set_algorithm(algorithm_type);
    void set_algorithm(std::string);
    void read_input_file(std::string);
    void set_output_filename(std::string);

    //! Sets bound constraints for the optimization problem.
    /**
     * @param[in] lower   An array of lower bounds, corresponding to
     *                    the vector of independent parameters. It is 
     *                    assumed that an array of size N_parameters has
     *                    been properly allocated.  
     * @param[in] upper   An array of upper bounds, corresponding to
     *                    the vector of independent parameters. It is 
     *                    assumed that an array of size N_parameters has
     *                    been properly allocated.  
    */
    void set_bound_constraints(double* lower, double* upper);

    //! Solve the optimization problem that has been set up.
    /**
     * The return value is the minimum value found for the objective function.
     */
    double optimize();

    int get_N_parameters();
    int get_best_function_evaluation();
    int get_function_evaluations();
    double* get_state_vector();
    void set_centered_differences(bool);
    void set_finite_difference_step_size(double);
    void set_max_function_evaluations(int);
    void set_verbose(int);
    void set_output_filename(std::string&);

    //! Pass the prescribed pointer to the objective function whenever it is called.
    /**
     * This method allows any data structure to be passed to the objective function.
     */
    void set_user_data(void* user_data);

    //! Impose bound constraints on an optimization problem, with the bounds chosen as multiples of the initial state vector.
    /**
     * To use this subroutine, you must first call mango::Problem::set_bound_constraints, so MANGO has pointers to the 
     * arrays allocted by the user for lower and upper bounds. mango::Problem::set_relative_bound_constraints will overwrite the entries of these arrays.
     *
     * There are two possible methods of determining the bound constraints using this subroutine, depending
     * on the parameter preserve_sign. 
     *
     * If preserve_sign is false, the bounds will be symmetric about 0, given by the value
     * of the initial condition multiplied by max_factor, expanded to be at least min_radius different from
     * the initial condition. Thus, for independent
     * variable \f$ x_j \f$, the bounds will be \f$ x_j \in [-R_j, R_j] \f$, where
     * \f$ R_j = \max(\mathtt{min\_radius}, |x_j| \mathtt{max\_factor})\f$. 
     * Note that the parameter min_factor is not used in this case.
     *
     * If preserve_sign is true, the lower and upper bounds for a given independent variable
     * will have the same sign as the corresponding element of state_vector (the initial condition supplied to the constructor).
     * The bounds are determined by multiplying each independent variable by min_factor and max_factor, keeping
     * both bounds at least min_radius from the initial condition (while not crossing 0).
     * Thus, if independent variable \f$ x_j \f$ is positive, the bounds will be \f$ x_j \in [L_j, R_j] \f$ where
     * \f$ L_j = \max(0, \min(x_j - \mathtt{min\_radius}, x_j \, \mathtt{min\_factor})) \f$ and
     * \f$ R_j = \max(x_j + \mathtt{min\_radius}, x_j \, \mathtt{max\_factor}) \f$.
     * If independent variable \f$ x_j \f$ is negative, the bounds will be \f$ x_j \in [L_j, R_j] \f$ where
     * \f$ L_j = \min(x_j - \mathtt{min\_radius}, x_j \, \mathtt{max\_factor}) \f$ and
     * \f$ R_j = \min(0, \max(x_j + \mathtt{min\_radius}, x_j \, \mathtt{min\_factor})) \f$.
     * For the special case \f$x_j=0\f$, then the bounds are \f$ x_j \in [-\mathtt{min\_radius}, \mathtt{min\_radius}] \f$.
     *
     * Note that not every optimization algorithm allows bound constraints. If bound constraints
     * have been turned on with this subroutine and mango::Problem::optimize is called,
     * MANGO will check whether the selected algorithm supports bound constraints. If not,
     * a warning message will be printed to stdout, and the optimization will proceed,
     * ignoring the bound constraints.
     * @param min_factor See description above. The value must lie in [0,1] or else a C++ exception will be thrown.
     * @param max_factor See description above. The value must be \f$ \ge 1 \f$, or else a C++ expection will be thrown.
     * @param min_radius See description above. The value must be \f$ \ge 0 \f$, or else a C++ exception will be thrown.
     * @param preserve_sign See description above.
     */
    void set_relative_bound_constraints(double min_factor, double max_factor, double min_radius, bool preserve_sign);
  };

  
  //////////////////////////////////////////////////////////////////////////////////////
  // A least-squares problem is a subclass of Problem

  class Least_squares_solver;
  class Least_squares_problem : public Problem {
  private:
    // Many implementation details are hidden in the Least_squares_solver class, so users see only the interface provided by Least_squares_problem.
    Least_squares_solver* least_squares_solver;

  public:
    Least_squares_problem(int, double*, int, double*, double*, double*, residual_function_type, int, char**); // For least-squares problems

    //! Destructor
    ~Least_squares_problem();

    //! Return the number of least-squares terms that are summed to form the objective function.
    int get_N_terms();

    //! Determine whether or not to print each individual residual in the MANGO output file.
    /**
     * You may wish to print this information to see the relative magnitude of each term
     * in the objective function. On the other hand, for problems with many terms, you may
     * wish to suppress this information to make the file more readable.
     *
     * @param[in] print Whether or not to print every residual term in the output file.
     */
    void set_print_residuals_in_output_file(bool print);
  };
}

#endif
