<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MANGO: Calling MANGO from Fortran</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('fortran.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Calling MANGO from Fortran </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The use of MANGO from a Fortran application is described here. For a demonstration of the concepts here, you are strongly encouraged to look at the <a href="https://github.com/hiddenSymmetries/mango/tree/master/examples/src">examples in the git repository</a>.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Connecting your code to MANGO</h1>
<p>To use MANGO from your Fortran application, you must include use the <code><a class="el" href="namespacemango__mod.html" title="This Fortran module provides the Fortran API for calling MANGO from outside applications.">mango_mod</a></code> module from your source code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">use </span><a class="code" href="namespacemango__mod.html">mango_mod</a></div>
</div><!-- fragment --><p>MANGO also makes use of the standard Fortran module <code>iso_C_binding</code> in two ways. First, integers and doubles passed to and from MANGO should have type <code>C_int</code> and <code>C_double</code> respectively. These types are defined in the <code>iso_C_binding</code> module. Normally these types are the same as the Fortran types <code>integer</code> and <code>double precision</code>, but if the C and Fortran types differ due to compiler flags, MANGO will use the C types, since it uses C++ internally. Second, the <code>user_data</code> argument to your user-supplied objective function or residual function has the type <code>C_ptr</code> defined in <code>iso_C_binding</code>. If you pass data to your objective function using the <a class="el" href="interface_8cpp.html#a0254f27f3955fe741da01c41b2119109">mango_set_user_data</a> subroutine, you need to use the <code>C_loc</code> function from <code>iso_C_binding</code> to generate a pointer to your data of this type, and use the function <code>c_f_pointer</code> subroutine from <code>iso_C_binding</code> to convert the C pointer to a Fortran pointer. Therefore your objective/residual function and any routine that calls <a class="el" href="interface_8cpp.html#a0254f27f3955fe741da01c41b2119109">mango_set_user_data</a> must include </p><div class="fragment"><div class="line"><span class="keywordtype">use </span>iso_c_binding</div>
</div><!-- fragment --><p>When compiling your code, make sure the compiler is able to find the <code><a class="el" href="namespacemango__mod.html" title="This Fortran module provides the Fortran API for calling MANGO from outside applications.">mango_mod</a></code> module file, which typically has a filename like <code>mango_mod.mod</code> or <code>mango_mod.MOD</code>, depending on the compiler. This file will be located in the <code>include</code> subdirectory of MANGO. Typically the compiler can be instructed to look in this directory with a flag such as <code>-I &lt;mangodir&gt;/include</code> where <code>&lt;mangodir&gt;</code> is replaced by the appropriate directory on your system.</p>
<p>To link your code to MANGO, link to the file <code>libmango.a</code>, which is located in MANGO's <code>lib</code> subdirectory. Typically the linker can be instructed to link to this file with flags such as <code>-L &lt;mangodir&gt;/lib -lmango</code>, where <code>&lt;mangodir&gt;</code> is replaced by the appropriate directory on your system.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Defining an objective function</h1>
<p>For general optimization problems, the objective function is determined by a user-supplied subroutine with the form <a class="el" href="interfacemango__mod_1_1objective__function__interface.html" title="Format for the user-supplied subroutine that computes the objective function for a general (non least...">mango_mod::objective_function_interface</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>objective_function(N_parameters, state_vector, objective_value, failed, problem, user_data) <span class="keyword">bind(C)</span></div>
</div><!-- fragment --><p>where <code>objective_function</code> can be replaced with any name you like. The array <code>state_vector</code> is an input to your subroutine, indicating the values of the independent variables for which the objective function is to be evaluated. <code>N_parameters</code> is also provided as an input to the subroutine for convenience, as it gives the size of the <code>state_vector</code> array. After your subroutine has computed the objective function, the result (a numberof type <code>C_double</code>) should be stored in <code>objective_value</code>. If your calculation fails for some reason, you can return a value of 1 to <code>failed</code>; otherwise you can return 0 to <code>failed</code> or simply not set <code>failed</code>, since it defaults to 0.</p>
<p>The <a class="el" href="structmango__mod_1_1mango__problem.html" title="An object that represents an optimization problem.">mango_mod::mango_problem</a> object representing the optimization problem is supplied to your subroutine as <code>problem</code>. This is often useful so your subroutine can use information related to MPI, e.g. communicating between group leaders and workers.</p>
<p>The argument <code>user_data</code> is a pointer to any data structure you supply via the subroutine <a class="el" href="interface_8cpp.html#a0254f27f3955fe741da01c41b2119109">mango_set_user_data</a>. This argument is useful for passing information to your subroutine for the objective function, as discussed further below Note that <code>user_data</code> has <code>type(C_ptr)</code>, defined in the standard <code>iso_C_binding</code> module.</p>
<p>Your objective function subroutine should be given the attribute <code>bind(C)</code> (as shown above) since it will be called from C code in MANGO.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Defining the residuals for a least-squares problem</h1>
<p>If your problem has least-squares structure, then instead of supplying the objective function as described in the previous section, you must write a subroutine that computes the vector of residuals \(R_j\) described in <a class="el" href="concepts.html">Core Concepts</a>. This subroutine must have the form <a class="el" href="interfacemango__mod_1_1vector__function__interface.html" title="Format for the user-supplied subroutine that computes the residuals for a least-squares optimization ...">mango_mod::vector_function_interface</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>residual_function(N_parameters, state_vector, N_terms, residuals, failed, problem, user_data) <span class="keyword">bind(C)</span></div>
</div><!-- fragment --><p>where <code>residual_function</code> can be replaced with any name you like. The array <code>state_vector</code> is an input to your subroutine, indicating the values of the independent variables for which the residuals are to be evaluated. <code>N_parameters</code> is also provided as an input to the subroutine for convenience, as it gives the size of the <code>state_vector</code> array. Note that your subroutine should compute \(R\), not \((R - T)/\sigma\) (using the notation from <a class="el" href="concepts.html">Core Concepts</a>); the \(T\) and \(\sigma\) arrays are set separately when you create the <a class="el" href="structmango__mod_1_1mango__problem.html" title="An object that represents an optimization problem.">mango_mod::mango_problem</a> object. After your subroutine has computed the vector \(R\), the results should be stored in the <code>residuals</code> array. The size of this array, <code>N_terms</code>, is provided as an input to the subroutine for convenience. If your calculation fails for some reason, you can return a value of 1 to <code>failed</code>; otherwise you can return 0 to <code>failed</code> or simply not set <code>failed</code>, since it defaults to 0.</p>
<p>The <a class="el" href="structmango__mod_1_1mango__problem.html" title="An object that represents an optimization problem.">mango_mod::mango_problem</a> object representing the optimization problem is supplied to your subroutine as <code>problem</code>. This is often useful so your subroutine can use information related to MPI, e.g. communicating between group leaders and workers.</p>
<p>The argument <code>user_data</code> is a pointer to any data structure you supply via the method <a class="el" href="interface_8cpp.html#a0254f27f3955fe741da01c41b2119109">mango_set_user_data()</a>. This argument is useful for passing information to your subroutine for the objective function, as discussed further below. Note that <code>user_data</code> has <code>type(C_ptr)</code>, defined in the standard <code>iso_C_binding</code> module.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Creating an optimization problem object</h1>
<p>MANGO optimization problems (both general and least-squares) are represented in Fortran by the type <code>mango_problem</code> defined in the <code><a class="el" href="namespacemango__mod.html" title="This Fortran module provides the Fortran API for calling MANGO from outside applications.">mango_mod</a></code> module:</p>
<div class="fragment"><div class="line"><span class="keywordtype">type</span>(mango_problem) :: myprob</div>
</div><!-- fragment --><p>After such an object is declared, a general optimization problem can be created by calling <a class="el" href="interface_8cpp.html#a29ce2b6aba6508663cb162849e760617">mango_problem_create</a> :</p>
<div class="fragment"><div class="line"><span class="comment">call mango_problem_create(myprob, N_parameters, state_vector, objective_function)</span></div>
</div><!-- fragment --><p>where <code>myprob</code> can be changed to whatever name you wish. You should set the integer <code>N_parameters</code> to the number of independent variables. The values of these variables for the initial state should be stored in the user-allocated array <code>state_vector</code> (which has type <code>C_double</code>). (As a general rule, MANGO gives the user responsibility for allocating memory.) The values of the <code>state_vector</code> array will not be copied or used until you actually invoke <a class="el" href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a>, so you are free to change the entries in <code>state_vector</code> after calling <a class="el" href="interface_8cpp.html#a29ce2b6aba6508663cb162849e760617">mango_problem_create</a>. After the optimization is completed, the same <code>state_vector</code> array will hold the location of the optimum found.</p>
<p>A pointer to the user-supplied subroutine for computing the objective function is given by the <code>objective_function</code> argument.</p>
<p>For problems with least-squares structure, then instead of calling <a class="el" href="interface_8cpp.html#a29ce2b6aba6508663cb162849e760617">mango_problem_create</a>, you should call <a class="el" href="interface_8cpp.html#a012721d8f9baa12c1398ced5fc597811">mango_problem_create_least_squares</a> :</p>
<div class="fragment"><div class="line"><span class="comment">call mango_problem_create_least_squares(myprob, N_parameters, state_vector, N_terms, targets, sigmas, best_residual_function, residual_function)</span></div>
</div><!-- fragment --><p>Again, <code>myprob</code> can be replaced with whatever name you like. The arguments <code>N_parameters</code> and <code>state_vector</code> have exactly the same meaning as for a general optimization problem. The integer <code>N_terms</code> provides the number of least-squares terms that are summed in the objective function, i.e. \(N_t\) in <a class="el" href="concepts.html">Core Concepts</a>. The double precision arrays <code>targets</code> and <code>sigmas</code>, both of size <code>N_terms</code>, correspond to the quantities \(T_j\) and \(\sigma_j\) in <a class="el" href="concepts.html">Core Concepts</a>, shifting and scaling the terms in the objective function. The double precision array <code>best_residual_function</code> will store the values of the residuals \(R_j\) at the optimum after the optimization is completed. Note that you have responsibility for allocating <code>targets</code>, <code>sigmas</code>, and <code>best_residual_function</code>. The argument <code>residual_function</code> is a pointer to the user-supplied subroutine for computing the residuals \(R_j\), and <code>residual_function</code> can be replaced by whichever subroutine name you use in your code.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Setting parameters</h1>
<p>A number of subroutines are provided to set options and parameters. To set the optimization algorithm, see <a class="el" href="algorithms.html">Available Algorithms</a>.</p>
<p>In general, the Fortran API is similar to the C++ API, except that Fortran subroutines take the optimization problem object as an extra first argument, and Fortran subroutine names begin with <code>mango_</code>.</p>
<p>The subroutine <a class="el" href="interface_8cpp.html#acdb1b08291d455e6fe92a8e6d68bbbb9">mango_set_max_function_evaluations</a> sets the maximum number of times the objective function will be evaluated, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_max_function_evaluations(myprob, 1000)</span></div>
</div><!-- fragment --><p>where <code>myprob</code> is the optimization problem object (of type <a class="el" href="structmango__mod_1_1mango__problem.html" title="An object that represents an optimization problem.">mango_mod::mango_problem</a>). The limit you set may be exceeded slightly because concurrent function evaluations will always be allowed to complete. For instance, if this limit is set to 1000, a finite-difference gradient calculation involving 10 function evaluations may be initiated when the objective function has been evaluated 995 times, resulting in 1005 evaluations in total.</p>
<p>To control whether centered or one-sided finite differences are used for gradient evaluations, use <a class="el" href="interface_8cpp.html#aaedf80994106bde530402260ec6f76d9">mango_set_centered_differences</a>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_centered_differences(myprob, .false.)</span></div>
</div><!-- fragment --><p>The step size in the independent variables used for finite difference derivatives is set using <a class="el" href="interface_8cpp.html#a469af3fcc7bd0cd50c7906ad9f37e27e">mango_set_finite_difference_step_size</a> :</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_finite_difference_step_size(myprob, 1.0e-6)</span></div>
</div><!-- fragment --><p>MANGO writes an ASCII file containing the history of evaluations of the objective function, and the name of this file can be set using <a class="el" href="interface_8cpp.html#ac2d2105b306ab4b5881a372cbd77e62b">mango_set_output_filename</a> :</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_output_filename(myprob, &quot;mango_out.rosenbrock&quot;)</span></div>
</div><!-- fragment --><p>where the string can be replaced by any filename you like.</p>
<p>For least-squares problems, this output file can be set to include or not include the values of the individual residual terms. It may be illuminating to view this information, though for problems with a large number of residual terms, it may be easier to read the output file if this large volume of information is suppressed. This choice can be controlled using <a class="el" href="interface_8cpp.html#a13f00e4bc6571c288d18790db3c3bf05">mango_set_print_residuals_in_output_file</a> :</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_print_residuals_in_output_file(myprob, .false.)</span></div>
</div><!-- fragment --><p>If you wish, a separate output file can be generated containing the information about the MPI partition, e.g. which processors are in which worker group. This file can be written using <a class="el" href="interface_8cpp.html#aa95c1dd7ec4e85fed1c38fccd94d34cc">mango_mpi_partition_write</a>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">call mango_mpi_partition_write(myprob, &quot;mango_mpi.rosenbrock&quot;)</span></div>
</div><!-- fragment --><p>where the string can be replaced by any filename you like.</p>
<p>If you wish to impose bound constraints (also known as box constraints) on your problem, you can call <a class="el" href="interface_8cpp.html#a7bf7e389a3312864ba0a3f83688d9a69">mango_set_bound_constraints</a>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_bound_constraints(myprob, lower_bounds, upper_bounds)</span></div>
</div><!-- fragment --><p>Here, <code>lower_bounds</code> and <code>upper_bounds</code> are arrays of type <code>double precision</code> and are user-allocated arrays of size <code>N_parameters</code>. Note that not all algorithms support bound constraints. The elements of these arrays are not copied or used until <a class="el" href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a> is called, so you can change the lower and upper bounds after the call to <a class="el" href="interface_8cpp.html#a7bf7e389a3312864ba0a3f83688d9a69">mango_set_bound_constraints</a>.</p>
<p>Alternatively, the related subroutine <a class="el" href="interface_8cpp.html#ad17d8099dc083af17cae67ad21e219c6">mango_set_relative_bound_constraints</a> lets you automatically set bound constraints based on a specified multiple of and/or distance from the initial condition. For instance, to let each parameter vary between 0.5 and 2 times its initial value, you can call</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_relative_bound_constraints(myprob, 0.5, 2.0, 0.0, .true.)</span></div>
</div><!-- fragment --><p>MANGO's Levenberg-Marquardt algorithm uses a parallelized line search in which, by default, the number of values of the \(\lambda\) parameter considered between Jacobian evaluations is equal to the number of worker groups. This choice generally makes the best use of parallelization, but it makes the optimization history depend on the number of worker groups, and hence possibly on the number of MPI processes. You may occasionally wish for the number of values of \(\lambda\) examined to be some specified value different from the number of worker groups, particularly for tests related to parallelization. In this case, you can specify the number of \(\lambda\) values to use with <a class="el" href="interface_8cpp.html#ab97a507a5cdc6464d7a9e4d673d56895">mango_set_N_line_search</a>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_N_line_search(myprob, 3)</span></div>
</div><!-- fragment --><p>By default, MANGO will not print information to stdout. To turn on the printing of information for debugging you can use <a class="el" href="interface_8cpp.html#a7b6b3da9a8cc647c4cd455cf4efdfd97">mango_set_verbose</a>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_verbose(myprob, 1)</span></div>
</div><!-- fragment --><p>You can pass any variable or data structure to your subroutine for the objective function or residuals using <a class="el" href="interface_8cpp.html#a0254f27f3955fe741da01c41b2119109">mango_set_user_data</a>, e.g.</p>
<div class="fragment"><div class="line"><span class="keywordtype">integer</span> :: mydata = 42</div>
<div class="line">...</div>
<div class="line"><span class="keyword">call </span><a class="code" href="interface_8cpp.html#a0254f27f3955fe741da01c41b2119109">mango_set_user_data</a>(myprob, c_loc(mydata))</div>
</div><!-- fragment --><p>The <code>C_loc</code> function used here is in the standard Fortran module <code>iso_C_binding</code>.</p>
<p>The pointer that you provide will be passed to your subroutine for the objective function or residuals as the <code>user_data</code> argument, which has <code>type(C_ptr)</code>. (See <a class="el" href="interfacemango__mod_1_1objective__function__interface.html" title="Format for the user-supplied subroutine that computes the objective function for a general (non least...">mango_mod::objective_function_interface</a> and <a class="el" href="interfacemango__mod_1_1vector__function__interface.html" title="Format for the user-supplied subroutine that computes the residuals for a least-squares optimization ...">mango_mod::vector_function_interface</a>) To use the data in your subroutine, you must convert the pointer from a C to Fortran pointer using the <code>c_f_pointer</code> subroutine in <code>iso_C_binding</code>: </p><div class="fragment"><div class="line"><span class="keyword">subroutine </span>objective_function(N_parameters, state_vector, objective_value, failed, myprob, user_data)</div>
<div class="line">  <span class="keywordtype">use </span>iso_c_binding</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">pointer</span> :: f_user_data</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">call </span>c_f_pointer(user_data, f_user_data)</div>
<div class="line">  ! now f_user_data == 42.</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md28"></a>
MPI considerations</h1>
<p>Your code (not MANGO) is responsible for calling <code>MPI_Init()</code> and <code>MPI_Finalize()</code>.</p>
<p>The set of MPI processes must be divided up into worker groups. This can either be done by MANGO or you are welcome to do it yourself. It is strongly recommended to have MANGO handle the division into worker groups. In this case, you can set the number of worker groups using <a class="el" href="interface_8cpp.html#a5c41ddf57869389c88bc01f9568bf904">mango_set_N_worker_groups</a>. Then, after calling <code>MPI_Init</code>, call <a class="el" href="interface_8cpp.html#a33e5b763797dd1d251cd9377ab9e4d93">mango_mpi_init</a> as follows:</p>
<div class="fragment"><div class="line"><span class="comment">call mango_set_N_worker_groups(myprob, 5)</span></div>
<div class="line"><span class="comment">call mango_mpi_init(myprob, MPI_COMM_WORLD)</span></div>
</div><!-- fragment --><p>where <code>myprob</code> is the name of the <a class="el" href="structmango__mod_1_1mango__problem.html" title="An object that represents an optimization problem.">mango_mod::mango_problem</a> object you have created. If you want MANGO to only use a subset of the processes in <code>MPI_COMM_WORLD</code>, then use the appropriate MPI communicator in the code line above. If you have selected an optimization algorithm that does not support concurrent function evaluations, MANGO will automatically change the number of worker groups to 1.</p>
<p>If you prefer to do your own division of processes into worker groups, you can call <a class="el" href="interface_8cpp.html#ab5f1242912d25d75c28561e54c5ffe0d">mango_mpi_partition_set_custom</a> instead of <a class="el" href="interface_8cpp.html#a33e5b763797dd1d251cd9377ab9e4d93">mango_mpi_init</a>.</p>
<p>Once MANGO's MPI information has been initialized by one of these two methods, methods are available to get the three MPI communicators discussed in <a class="el" href="concepts.html">Core Concepts</a>, <a class="el" href="interface_8cpp.html#a04e7f55b447e37bf4139b791f05fec6c">mango_get_mpi_comm_world</a>, <a class="el" href="interface_8cpp.html#ad509a5d7a016bd640674b3a9adc2ea79">mango_get_mpi_comm_worker_groups</a>, and <a class="el" href="interface_8cpp.html#a164a1a0e24a402aa6c05bf5f25dfa1d2">mango_get_mpi_comm_group_leaders</a>. The number of processes in each communicator can be queried with <a class="el" href="interface_8cpp.html#ac86350cc051fbea6c3dbed05977cb60c">mango_get_N_procs_world</a>, <a class="el" href="interface_8cpp.html#a4434d6f59d686a831f46a4531a0c17a9">mango_get_N_procs_worker_groups</a>, and <a class="el" href="interface_8cpp.html#add9fd615ae4a61d36ae7640bd3493443">mango_get_N_procs_group_leaders</a>. The rank of a given process within each of the communicators can be obtained with <a class="el" href="interface_8cpp.html#a486e85f527d4469258f2955e53e453a8">mango_get_mpi_rank_world</a>, <a class="el" href="interface_8cpp.html#ae4461789eac03c7cefffec15dba9f5cd">mango_get_mpi_rank_worker_groups</a>, and <a class="el" href="interface_8cpp.html#a9de71893174e2a6780032304bd3e4c06">mango_get_mpi_rank_group_leaders</a>. To determine if a given process has rank = 0 within a given communicator, you can call <a class="el" href="interface_8cpp.html#a6fb89ff89b6640eb27ab4939098ce034">mango_get_proc0_world</a> and <a class="el" href="interface_8cpp.html#ac18bce26af174f7a2aecdb01f364f91a">mango_get_proc0_worker_groups</a>. The number of worker groups and the worker group that a given process belongs to can be found using <a class="el" href="interface_8cpp.html#a9f907dfaa82778a719905898675a193f">mango_get_N_worker_groups</a> and <a class="el" href="interface_8cpp.html#ad660cce68792b68866e36ee3d836d2db">mango_get_worker_group</a>.</p>
<p>MANGO provides several subroutines that may be convenient for handling communication between group leaders and workers: <a class="el" href="interface_8cpp.html#a54334973560eab929d1ef58f043ffed8">mango_mobilize_workers</a>, <a class="el" href="interface_8cpp.html#a2f91f4efd735250c93e0e7a638d76157">mango_stop_workers</a>, and <a class="el" href="interface_8cpp.html#a5f9e4e7cdfcdd0a56398016f2061792a">mango_continue_worker_loop</a>. Use of these subroutines is optional. These subroutines are demonstrated in all of the <a href="https://github.com/hiddenSymmetries/mango/tree/master/examples/src">examples</a>. In typical usage, workers use <a class="el" href="interface_8cpp.html#a5f9e4e7cdfcdd0a56398016f2061792a">mango_continue_worker_loop</a> to wait until they are needed to evaluate the objective function, and exit when the optimization is complete:</p>
<div class="fragment"><div class="line"><span class="comment">! This code is run only by workers, not group leaders.</span></div>
<div class="line"><span class="keywordflow">do</span> <span class="keywordflow">while</span> (<a class="code" href="interface_8cpp.html#a5f9e4e7cdfcdd0a56398016f2061792a">mango_continue_worker_loop</a>(myprob))</div>
<div class="line">  <span class="comment">! Here, communicate with my group leader via MPI and help it to evaluate the objective function.</span></div>
<div class="line"><span class="keywordflow">end do</span></div>
<div class="line">! we <span class="keywordflow">exit</span> the above loop when <a class="code" href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a>() completes.</div>
</div><!-- fragment --><p>Meanwhile, a group leader causes its workers to evaluate the code inside the above <code>do while</code> loop (i.e. causes <a class="el" href="interface_8cpp.html#a5f9e4e7cdfcdd0a56398016f2061792a">mango_continue_worker_loop</a> to evaluate to <code>.true.</code>) by calling <a class="el" href="interface_8cpp.html#a54334973560eab929d1ef58f043ffed8">mango_mobilize_workers</a> inside the user-supplied subroutine for the objective or residual function, e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>objective_function(N_parameters, state_vector, objective_value, failed, myprob, user_data)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">call </span><a class="code" href="interface_8cpp.html#a54334973560eab929d1ef58f043ffed8">mango_mobilize_workers</a>(myprob)</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>When the group leaders are done with the optimization, they should instruct the workers to exit the <code>do while</code> loop above:</p>
<div class="fragment"><div class="line"><span class="comment">call mango_stop_workers(myprob)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29"></a>
Running the optimization</h1>
<p>Once parameters have been set, the optimization is actually performed with the function <a class="el" href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a>. The lowest value of the objective function is returned, e.g.</p>
<div class="fragment"><div class="line">best_objective_function = <a class="code" href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a>(myprob)</div>
</div><!-- fragment --><p>The subroutine <a class="el" href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a> should be called by all group leaders, but not by workers.</p>
<p>Once <a class="el" href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a> has completed, the values of the independent variables at the optimum are available in the <code>state_vector</code> array you provided to the <a class="el" href="classmango_1_1Problem.html">mango::Problem</a> constructor. Further details of the optimization can be obtained using <a class="el" href="interface_8cpp.html#ac9b60ef0e98d0e55c6be8e84a1bf4f55">mango_get_function_evaluations</a> and <a class="el" href="interface_8cpp.html#a5b9b47ad5de703fda98858a3108569c9">mango_get_best_function_evaluation</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="ainterface_8cpp_html_a0254f27f3955fe741da01c41b2119109"><div class="ttname"><a href="interface_8cpp.html#a0254f27f3955fe741da01c41b2119109">mango_set_user_data</a></div><div class="ttdeci">void mango_set_user_data(mango::Problem *This, void *user_data)</div><div class="ttdef"><b>Definition:</b> <a href="interface_8cpp_source.html#l00218">interface.cpp:218</a></div></div>
<div class="ttc" id="ainterface_8cpp_html_a5f9e4e7cdfcdd0a56398016f2061792a"><div class="ttname"><a href="interface_8cpp.html#a5f9e4e7cdfcdd0a56398016f2061792a">mango_continue_worker_loop</a></div><div class="ttdeci">int mango_continue_worker_loop(mango::Problem *This)</div><div class="ttdef"><b>Definition:</b> <a href="interface_8cpp_source.html#l00230">interface.cpp:230</a></div></div>
<div class="ttc" id="ainterface_8cpp_html_a54334973560eab929d1ef58f043ffed8"><div class="ttname"><a href="interface_8cpp.html#a54334973560eab929d1ef58f043ffed8">mango_mobilize_workers</a></div><div class="ttdeci">void mango_mobilize_workers(mango::Problem *This)</div><div class="ttdef"><b>Definition:</b> <a href="interface_8cpp_source.html#l00226">interface.cpp:226</a></div></div>
<div class="ttc" id="anamespacemango__mod_html"><div class="ttname"><a href="namespacemango__mod.html">mango_mod</a></div><div class="ttdoc">This Fortran module provides the Fortran API for calling MANGO from outside applications.</div><div class="ttdef"><b>Definition:</b> <a href="mango_8F90_source.html#l00023">mango.F90:23</a></div></div>
<div class="ttc" id="ainterface_8cpp_html_a1f5c4e58982e0598c25b94d61e293e07"><div class="ttname"><a href="interface_8cpp.html#a1f5c4e58982e0598c25b94d61e293e07">mango_optimize</a></div><div class="ttdeci">double mango_optimize(mango::Problem *This)</div><div class="ttdef"><b>Definition:</b> <a href="interface_8cpp_source.html#l00108">interface.cpp:108</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
